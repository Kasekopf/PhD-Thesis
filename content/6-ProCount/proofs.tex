



\section{Proofs}
\label{appendix:proofs}

\subsection{Proof of Theorem \ref{thm:proj_valuation}}
When performing a product followed by a projection, it is often possible to perform the projection first.
This is known as \emph{early projection} \cite{mcmahan2004projection}, which forms the core of the proof of Theorem \ref{thm:proj_valuation}.
\begin{theorem}[Early Projection]
\label{thm:early_projection}
    Let $X$ and $Y$ be sets of variables.
    For all functions $f: 2^X \to \R$ and $g: 2^Y \to \R$, if $x \in X \setminus Y$, then $\Sigma_x (f \mult g) = \pars{\Sigma_x f} \mult g$ and $\exists_x (f \mult g) = \pars{\exists_x f} \mult g.$
    % As a corollary, for all $X' \subseteq X \setminus Y$,
    % $$\exists_{X'} (A \mult B) = \pars{\exists_{X'} A} \mult B.$$
\end{theorem}

We ultimately prove Theorem \ref{thm:proj_valuation} by structural induction. 
It is therefore helpful to have some additional notations for subtrees of project-join trees.
Let $(T, r, \gamma, \pi)$ be a project-join tree for $\phi$, and let $n \in \V{T}$. Denote by $S(n) \subseteq \V{T}$ the set of all descendants of $n$ in $T$ (including $n$ itself). 
Let $P(n) = \bigcup_{o \in S(n) \setminus \Lv{T}} \pi(o)$ be the set of all variables projected in $S(n)$, and let $\Phi(n) = \{ \gamma(\ell) : \ell \in \Lv{T} \cap S(n) \}$ be the set of all clauses that appear as leaves in $S(n)$.

The key property of project-join trees is that variables projected in one branch of the tree cannot appear in sibling branches of the tree. Formally:
\begin{lemma}
\label{lemma:disjoint_P}
    In a project-join tree $(T, r, \gamma, \pi)$, let $n$ be an internal node with children $o \ne q$.
    Then $P(o) \cap \vars \pars{\Phi(q)} = \emptyset$.
\end{lemma}
\begin{proof}
    Let variable $x \in P(o)$.
    Notice that $x \in \pi(s)$ for some internal node $s$ that is a descendant of $o$.
    Assume there is an arbitrary clause $c \in \phi$ \st{} $x$ appears in $c$.
    By the last property in Definition \ref{def_jointree_old}, the corresponding leaf $\gamma^{-1}(c)$ is a descendant of $s$ and thus a descendant of $o$.
    So $x$ appears in no descendant leaf of $q$ (as $q$ is a sibling of $o$ in the tree $T$).
    Thus $x \notin \vars(\Phi(q))$. Since $x \in P(o)$ is arbitrary, we conclude that $P(o) \cap \vars \pars{\Phi(q)} = \emptyset$.
\end{proof}

Using Lemma \ref{lemma:disjoint_P}, we can prove that projected-valuations have an equivalent, non-recursive definition:
\begin{lemma}
\label{lemma:proj_valuation}
Let $(X, Y, \phi, W)$ be an instance of weighted projected model counting, and let $\T$ be an $(X,Y)$-graded project-join tree for $\phi$.

Define, for every node $n$ of $T$,
\begin{equation*}
    h^W_n = \left( \prod_{C \in \Phi(n)} [C] \right) \mult \left( \prod_{x \in P(n) \cap X} W_x \right).
\end{equation*}

Then for every node $n$ of $T$,
\begin{equation}
\label{eqn:proj_valuation_lemma}
    g^W_n = \sum_{P(n) \cap X} \displaystyle\exist_{P(n) \cap Y} h^W_n.
\end{equation}
\end{lemma}
\begin{proof}
We employ structural induction on $n \in \V{T}$.
In the base case, $n$ is a leaf. Then $P(n) = \emptyset$ and $\Phi(n) = \{ \gamma(n) \}$. Thus $h^W_n = \left( \prod_{C \in \{ \gamma(n) \} } [C] \right) \mult \left( \prod_{x \in \emptyset} W_x \right) = [\gamma(n)]$, so the right-hand side of Equation \eqref{eqn:proj_valuation_lemma} is
$\sum_\emptyset \exist_\emptyset h^W_n = h^W_n = [\gamma(n)]$, which is exactly $g^W_n$.

In the inductive case, $n$ is an internal node of $T$ and, for each $o \in \C{T}{r}{n}$, we have
$g^W_o = \sum_{P(o) \cap X} \exist_{P(o) \cap Y} h^W_o$.

Consider the product
\begin{equation}
\label{eqn:proj_valuation_child_product}
    \prod_{o \in \C T r n} g^W_o = \prod_{o \in \C T r n} \sum_{P(o) \cap X} \displaystyle\exist_{P(o) \cap Y} h^W_o.
\end{equation}

By Lemma \ref{lemma:disjoint_P}, for distinct $o, q \in \C{T}{r}{n}$, we know $P(o) \cap \vars(\Phi(q)) = \emptyset$. Thus $P(o) \cap \vars(h^W_q) = \emptyset$ as well. We can therefore apply Theorem \ref{thm:early_projection} to Equation \eqref{eqn:proj_valuation_child_product} to get that
\begin{equation}
\prod_{o \in \C{T}{r}{n}} g^W_o = \sum_{A \cap X} \prod_{o \in \C{T}{r}{n}} \displaystyle\exist_{P(o) \cap Y} h^W_o = \sum_{A \cap X} \displaystyle\exist_{A \cap Y} \prod_{o \in \C{T}{r}{n}} h^W_o \label{eq_child_prod}
\end{equation}
where $A = \bigcup_{o \in \C{T}{r}{n}} P(o)$.

Let $\mathcal{I}_X$ and $\mathcal{I}_Y$ be the grades of $\T$. By Definition \ref{def:graded}, either $n \in \mathcal{I}_X$ or $n \in \mathcal{I}_Y$. We divide the inductive case further into these two cases.

\paragraph{Case: $n \in \mathcal{I}_Y$.} Then for each $p \in S(n)$, by Definition \ref{def:graded}, we have $p \in \mathcal{I}_Y$, so $\pi(p) \subseteq Y$. Thus $A \subseteq Y$. 
By Definition \ref{def:graded_valuation} and Equation \eqref{eq_child_prod}, we have
\begin{equation*}
    g^W_n = \displaystyle\exist_{\pi(n)} \prod_{o \in \C{T}{r}{n}} g^W_o = \displaystyle\exist_{\pi(n)} \displaystyle\exist_{A} \prod_{o \in \C{T}{r}{n}} h^W_o = \displaystyle\exist_{P(n)} \prod_{o \in \C{T}{r}{n}} h^W_o.
\end{equation*}

We therefore conclude that $$g^W_n = \displaystyle\exist_{P(n)} \prod_{o \in \C{T}{r}{n}} \prod_{C \in \Phi(o)} [C] = \displaystyle\exist_{P(n)} \prod_{C \in \Phi(n)} [C] = \displaystyle\exist_{P(n)} h^W_n.$$

\paragraph{Case: $n \in \mathcal{I}_X$.} Thus $\pi(n) \subseteq X$. 
By Definition \ref{def:graded_valuation} and Equation \eqref{eq_child_prod}, we have
\begin{align*}
    g^W_n 
    &= \displaystyle\sum_{\pi(n)} \pars{ \prod_{o \in \C T r n} g^W_o \cdot \prod_{x \in \pi(n)} W_x }\\ 
    &= \sum_{\pi(n)} \pars{ \pars{ \sum_{A \cap X} \displaystyle\exist_{A \cap Y} \prod_{o \in \C{T}{r}{n}} h^W_o } \cdot \prod_{x \in \pi(n)} W_x }.
\end{align*}
Since $\pi(n) \cap A = \emptyset$, we can apply Theorem \ref{thm:early_projection} (in the other direction, which undoes early projection) to get that
\begin{equation*}
    g^W_n = \sum_{\pi(n)} \pars{ \sum_{A \cap X} \displaystyle\exist_{A \cap Y} \left( \prod_{o \in \C{T}{r}{n}} h^W_o \cdot \prod_{x \in \pi(n)} W_x \right) }.
\end{equation*}
Finally, observe that $\pi(n) \cup A = P(n)$ and that $h^W_n = \prod_{o \in \C{T}{r}{n}} h^W_o \cdot \prod_{x \in \pi(n)} W_x$. We therefore conclude that
\begin{equation*}
    g^W_n = \sum_{P(n) \cap X} \displaystyle\exist_{P(n) \cap Y} \left( \prod_{o \in \C{T}{r}{n}} h^W_o \cdot \prod_{x \in \pi(n)} W_x \right) =  \sum_{P(n) \cap X} \displaystyle\exist_{P(n) \cap Y} h^W_n.
\end{equation*}
\end{proof}

Moreover, this non-recursive definition is equivalent to the weighted projected model count at the root node.
\begin{theorem}{\ref{thm:proj_valuation}}
Let $(X, Y, \phi, W)$ be an instance of weighted projected model counting, and let $\T$ be a project-join tree for $\phi$ with root $r$. 
If $\T$ is $(X, Y)$-graded, then $g^W_r(\emptyset) = \func{WPMC}(\phi, W, Y).$
\end{theorem}
\begin{proof}
As $r$ is the root of the project-join tree, $P(r) = X \cup Y$ and $\Phi(r) = \phi$. By Lemma \ref{lemma:proj_valuation}, $$g^W_r = \sum_{X} \displaystyle\exist_{Y} h^W_n = \sum_{X} \displaystyle\exist_{Y} \left( \prod_{C \in \phi} [C] \right) \mult \left( \prod_{x \in X} W_x \right) = \sum_{X} \displaystyle\exist_{Y} [\phi] \mult W.$$
Thus $g^W_r(\emptyset)$ is exactly the $W$-weighted $Y$-projected model count of $\phi$.
\end{proof}



\subsection{Proof of Theorem \ref{thm:planning_free_correctness}}
\begin{theorem}{\ref{thm:planning_free_correctness}}
Let $\phi$ be a CNF formula, and let $F \subseteq \vars(\phi)$. 
If $\T$ is a project-join tree for $\phi \cup \{\func{virtual}(F)\}$, then Algorithm \ref{alg_planning_free} returns an $F$-free project-join tree for $\phi$ of width at most $\func{width}(\T)$.
\end{theorem}
\begin{proof}
Let $C_F = \func{virtual}(F)$.
Let $\T = (T, r, \gamma, \pi)$ be the input project-join tree for $\phi \cup \{ C_F \}$, and let $\T' = (T, s, \gamma', \pi')$ be the output of Algorithm \ref{alg_planning_free}. 
Moreover, let $\vars_{\T}(n)$ and $\vars_{\T'}(n)$ denote the sets of variables at a node $n$ of $\T$ and $\T'$ respectively.


First, we prove that $\T'$ is a project-join tree. Since $\gamma$ is a bijection onto $\phi \cup \{C_F\}$ and we have removed both $C_F$ and the leaf corresponding to $C_F$, $\gamma'$ is indeed a bijection onto $\phi$. 
Moreover, since every variable appears in exactly one set in the image of $\pi'$, the first condition of Definition \ref{def_jointree_old} is satisfied. Finally, each variable $y$ is projected out at the lowest common ancestor of all leaves corresponding to clauses that contain $y$; thus the second condition of Definition \ref{def_jointree_old} is satisfied. It follows that $\T'$ is a project-join tree.

Second, we prove that $\T'$ is $F$-free. 
Since $s$ has degree 1, $s$ is never the lowest common ancestor of a set of leaves of $\T'$. Thus $\pi'(s) \setminus F = \emptyset$. By line \ref{line_pi_F}, it follows that $\pi'(s) = F$, so $\T'$ is $F$-free.

%To do this, for a set of leaves $L \subseteq \Lv{T}$ and a root $o$, define $A_{T, o}(L) \in \V{T}$ to be the lowest common ancestor of $L$ in $(T, o)$. By Algorithm \ref{alg_planning_free}, for each $y \in \vars(\phi) \setminus F$, $y \in \pi'(A_{T,s}(\{ C : C \in \phi~\text{and}~y \in \vars(C)\}))$. We can then define $B: \V{T} \rightarrow \vars(\phi)$ by $A(n) = \{ x \in \vars(\phi) : \exists \ell, \ell' \in \Lv{T}~\text{s.t.}~n~\text{is on the shortest path between}~\ell~\text{and}~\ell',~\text{and}~x \in \vars(\gamma(\ell)) \cap \vars(\gamma(\ell'))\}$, i.e., $B(n)$ is the set of all variables $x$ such that there are two leaves, $\ell$ and $\ell'$, on different sides of $n$ whose clauses contain $x$.


Finally, we prove that the width of $\T'$ is at most $\func{width}(\T)$. 
To do this, if $S$ is a project-join tree and $n$ is a node of $S$, define $\func{rel}_S(n) \equiv \vars_S(n)$ for leaf nodes and $\func{rel}_S(n) \equiv \vars_S(n) \cup \pi(n)$ for internal nodes. Notice the size of $n$ in $S$ is exactly $|\func{rel}_S(n)|$, so the width of $S$ is exactly the maximum size of $\func{rel}_S(n)$ across all nodes $n$. 

Consider an arbitrary node $n \in \V{T} \setminus \{s\}$. Define:
\begin{align*}
    A(n) &= \set{ y : \exists \ell \in \Lv{T} \text{ s.t. $\ell$ is a descendant of $n$ in the rooted tree $(T, s)$ and } y \in \func{rel}_{\T'}(\gamma'(\ell)) } \\
    B(n) &= \set{ x \in \vars(\phi) : \exists \ell, \ell' \in \Lv{T} \text{ s.t. $n$ is between $\ell, \ell'$ in $(T, r)$ and } x \in \func{rel}_{\T}(\gamma(\ell)) \cap \func{rel}_{\T}(\gamma(\ell')) } \\
    B'(n) &= \set{ x \in \vars(\phi) : \exists \ell, \ell' \in \Lv{T} \text{ s.t. $n$ is between $\ell, \ell'$ in $(T, s)$ and } x \in \func{rel}_{\T'}(\gamma'(\ell)) \cap \func{rel}_{\T'}(\gamma'(\ell')) }
\end{align*}
Note that a node $n$ is \emph{between} $\ell, \ell' \in \V{T}$ if $n$ is on the unique shortest path between $\ell$ and $\ell'$. There are several key relationships among $A(n)$, $B(n)$, $B'(n)$, $\func{rel}_{\T}(n)$, and $\func{rel}_{\T'}(n)$: 
\begin{enumerate}
    \item By the construction in Algorithm \ref{alg_planning_free}, we know $\func{rel}_{\T'}(n) \setminus F = B'(n) \setminus F$ and $\func{rel}_{\T'}(n) \cap F = A(n) \cap F$.
    \item Since $\gamma$ and $\gamma'$ agree on all nodes of $T$ except for $s$, we know $B(n) \setminus F = B'(n) \setminus F$.
    \item Since $\vars(C_F) = F$, we know $B(n) \cap F = A(n) \cap F$.
    \item By Property \ref{prop2} of Definition \ref{def_jointree_old}, $B(n) \subseteq \func{rel}_\T(n)$. 
\end{enumerate}
Putting these relationships together, we observe that:
\begin{align*}
    \func{rel}_{\T'}(n) &= (\func{rel}_{\T'}(n) \setminus F) \cup (\func{rel}_{\T'}(n) \cap F) \\
    &= (B'(n) \setminus F) \cup (A(n) \cap F) \\
    &= (B(n) \setminus F) \cup (B(n) \cap F) \\
    &= B(n) \\
    &\subseteq \func{rel}_{\T}(n)
\end{align*}
Finally, observe that $\func{rel}_{\T'}(s) = \func{rel}_{\T}(s) = F$.
Hence the width of $\T'$ is indeed no larger than the width of $\T$, as desired.
\end{proof}
 
 \subsection{Proof of Theorem \ref{thm:planning_free_optimal}}
\begin{theorem}{\ref{thm:planning_free_optimal}}
Let $\phi$ be a CNF formula.
Let $F \subseteq \vars(\phi)$, and let $w$ be a positive integer. % Define $C_F$ to be a fresh clause with $\vars(C_F) = \vars(N) \cap X$.
If there is an $F$-free project-join tree for $\phi$ of width $w$, then there is a project-join tree for $\phi \cup \{\func{virtual}(F)\}$ of width $w$.
\end{theorem}
\begin{proof}
Let $\T$ be an $F$-free project-join tree for $\phi$ of width at most $w$. 
Produce $\T'$ by attaching to the root of $\T$ a new leaf node corresponding to $C_F$. 
Then $\T'$ is a project-join tree for $\phi \cup \{C_F\}$, and its width is identical to $\T$.
\end{proof}
% \begin{theorem}\label{thm:free_reduction}
% Let $\phi$ be a CNF formula, let $F \subseteq \vars(\phi)$, and let $w$ be a positive integer. 
% Define $C_F$ to be a new clause with $\vars(C_F) = F$.

% Then there is an $F$-free project-join tree for $\phi$ of width at most $w$ if and only if there is a project-join tree for $\phi \cup \{C_F\}$ of width at most $w$.
% \end{theorem}
% \begin{proof}[Proof] 
% First, let $\T = (T, r, \gamma, \pi)$ be a project-join tree for $\phi \cup \{C_F\}$ of width at most $w$. The key idea is to re-root $\T$ so that the leaf labeled by $\C_F$ becomes the new root. Formally, let $s \in \V{T}$ be the parent of $\gamma^{-1}(C_F)$. Then there exists $\pi': \V{T} \setminus \Lv{T} \to 2^{\vars(\phi)}$ so that $\T' = (T, s, \gamma, \pi')$ is a project-join tree for $\phi \cup \{C_F\}$ of width at most $w$. Moreover, by Property 2 of project-join trees $F \subseteq \pi'(s)$.

% Conversely, let $\T$ be an $F$-free project-join tree for $\phi$ of width at most $w$. Produce $\T'$ by attaching a new leaf node labeled by $C_F$ to the root of $\T$. Since $\T$ is $F$-free, $\T'$ is indeed a project-join tree for $\phi \cup \{C_F\}$ of width at most $w$.
% \end{proof}

\subsection{Proof of Theorem \ref{thm:planning_graded_correctness}}
\begin{theorem}{\ref{thm:planning_graded_correctness}}
Let $\phi$ be a CNF formula. 
Let $\{X, Y\}$ be a partition of $\vars(\phi)$, and let $w$ be a positive integer. 
Assume each call to $\func{BuildComponent}(\alpha, F)$ returns an $F$-free project-join tree for $\alpha$ of width at most $w$. 
Then Algorithm \ref{alg_planning_graded} returns an $(X,Y)$-graded project-join tree for $\phi$ of width at most $w$.
\end{theorem}
\begin{proof}
Let $\T$ be the project-join tree produced on line \ref{alg_line_graded_project_x}, and let $\T' = (T, r, \gamma, \pi)$ be the project-join tree returned by Algorithm \ref{alg_planning_graded}. 
By Definition \ref{def:groupby}, every $y \in Y$ is a variable of exactly one $N_y \in \func{GroupBy}(\phi, Y)$. It follows that every $y \in Y$ is projected out at exactly one node of $\T'$, namely the node at which $y$ is projected out in $\T_{N_y}$. Similarly, after the loop on line \ref{alg_line_graded_loop} completes, no variable from $X$ is projected out across all of $\{\T_N : N \in \func{GroupBy}(\phi, Y)\}$, since all $X$ projections are removed on line \ref{alg_line_projections_removed}. Thus every $x \in X$ is also projected out at exactly one node of $\T'$, namely the node at which $x$ is projected out in $\T$. Thus $\T'$ satisfies the first property of Definition \ref{def_jointree_old}.

We prove the second property of Definition \ref{def_jointree_old} by contrapositive. That is, assume that there is some $n \in \V{T} \setminus \Lv{T}$, variable $z \in \pi(n)$, and $c \in \phi$ s.t. $z \in \vars(c)$ but $\gamma^{-1}(c)$ is not a descendant of $n$ in $\T'$. Let $N$ be the block of $\func{GroupBy}(\phi, Y)$ that contains $c$. We split into two cases:
\begin{itemize}
    \item \textit{Case: $z \in Y$.} Let $n'$ be the node in $\T_N$ that corresponds to $n$, where $z$ is projected. Then $\gamma^{-1}(c)$ is not a descendant of $n'$ in $\T_N$. It follows that $\T_N$ is not a project-join tree.
    \item \textit{Case: $z \in X$.} Let $n'$ be the node in $\T$ that corresponds to $n$, where $z$ is projected. Since  $\gamma^{-1}(c)$ is not a descendant of $n$ in $\T$, the leaf corresponding to $C_N$ is not a descendant of $n'$ in $\T$. But $z \in \vars(N) \cap X$, so $z \in \vars(C_N)$. It follows that $\T$ is not a project-join tree. 
\end{itemize} 
We conclude that $\T'$ satisfies the second property of Definition \ref{def_jointree_old} provided that $\func{BuildComponent}$ always returns project-join trees.

Finally, we prove that the width of $\T'$ is at most $w$. To see this, we observe that the set of variables at each node of $\T'$ is exactly the set of variables appearing at the node of the corresponding component project-join tree. The width of $\T'$ is thus the maximum size that appears across all component project-join trees returned by $\func{BuildComponent}$. 
\end{proof}

\subsection{Proof of Theorem \ref{thm:graded_from_virtual}}
\begin{theorem}{\ref{thm:graded_from_virtual}}
Let $\phi$ be a CNF formula, and let $\{X, Y\}$ be a partition of $\vars(\phi)$.
Let $w$ be a positive integer, and let $\psi = \phi \cup \{\func{virtual}(\vars(N)\cap X) : N \in \func{GroupBy}(\phi, Y)\}$.
% For each $N \in \func{GroupBy}(\phi, Y)$, define $C_N$ to be a new clause with $\vars(C_N) = \vars(N) \cap X$.
If there is a project-join tree $\T'$ for $\psi$ of width $w$, then there is an $(X,Y)$-graded project-join tree for $\phi$ of width at most $w$.
\end{theorem}
\begin{proof}
We first show that, for each call to $\func{BuildComponent}(\alpha, F)$ in Algorithm \ref{alg_planning_graded}, there is an $F$-free project-join tree for $\alpha$ of width at most $w$. There are two cases to consider: the calls on line \ref{alg_line_graded_project_y} and the call on line \ref{alg_line_graded_project_x}.
\begin{itemize}
    \item \textit{Case: line \ref{alg_line_graded_project_y}.} Consider some $N \in \func{GroupBy}(\phi, Y)$. Our goal is to find a $(\vars(N) \cap X)$-free project-join tree for $N$. Observe that $N \cup \{C_N\}$ is a subset of $\psi$. Thus let $S_N$ be the smallest subtree of $\T'$ containing all leaves labeled by some element of $N \cup \{C_N\}$. $S_N$ is a project-join tree for $N \cup \{C_N\}$ whose width is no more than $w$. By Theorem  \ref{thm:planning_free_correctness}, there is a $(\vars(N) \cap X)$-free project-join tree for $N$ of width no more than $w$.
    
    \item \textit{Case: line \ref{alg_line_graded_project_x}.} Similarly, let $N' = \{C_N : N \in \func{GroupBy}(\phi, Y)\}$ and observe that $N'$ is a subset of $\psi$. Let $S$ be the smallest subtree of $\T'$ containing all leaves labeled by some element of $N'$. Then $S$ is a project-join tree for $N'$ whose width is no more than $w$. 
\end{itemize}

It then follows from Theorem \ref{thm:planning_graded_correctness} that there is an $(X,Y)$-graded project-join tree for $\phi$ of width at most $w$. 
\end{proof}

\subsection{Proof of Theorem \ref{thm:planning_graded_optimal}}
\begin{theorem}{\ref{thm:planning_graded_optimal}}
Let $\phi$ be a CNF formula, and let $\{X, Y\}$ be a partition of $\vars(\phi)$.
Let $w$ be a positive integer, and let $\psi = \phi \cup \{\func{virtual}(\vars(N)\cap X) : N \in \func{GroupBy}(\phi, Y)\}$. % For each $N \in \func{GroupBy}(\phi, Y)$, define $C_N$ to be a new clause with $\vars(C_N) = \vars(N) \cap X$.
If there is an $(X,Y)$-graded project-join tree for $\phi$ of width $w$, then there is a project-join tree for $\psi$ of width $w$.
\end{theorem}
\begin{proof}
Let $\T$ be an $(X,Y)$-graded project-join tree for $\phi$ of width $w$, and let $\mathcal{I}_X, \mathcal{I}_Y$ be the grades of $\T$. 
We first aim to show that, for every $N \in \func{GroupBy}(\phi, Y)$, there is some node $n_N$ of $\T$ with $N \cap X \subseteq \vars(n_N)$. 

Consider an arbitrary $N \in \func{GroupBy}(\phi, Y)$. If $|N| = 1$, define $n_N$ to be the node of $\T$ corresponding to the only element of $N$; thus $\vars(n_N) = \vars(N)$, so indeed $N \cap X \subseteq \vars(n_N)$. 
Otherwise, define $n_N \in \V{T}$ to be the lowest common ancestor of $N$ in $\T$. 
Then there exist distinct clauses $A, B \in N$ s.t. $n_N$ is also the lowest common ancestor of the two leaves labeled by $A$ and $B$. 
By Definition \ref{def:groupby}, since $A, B \in N$, there must be a sequence $C_1, C_2, \cdots, C_k \in N$ s.t. $C_1 = A$, $C_k = B$, and for each $1 \leq i \leq k$, we have $\vars(C_i) \cap \vars(C_{i+1}) \cap Y \neq \emptyset$. 
Since $n_N$ is the lowest common ancestor of $A$ and $B$, and because $\T$ is a tree, there must be some $1 \leq i \leq k$ s.t. $n_N$ is also the lowest common ancestor of $C_i$ and $C_{i+1}$. Thus $\vars(C_i) \cap \vars(C_{i+1}) \subseteq \vars(n_N)$. 
Since $\vars(C_i) \cap \vars(C_{i+1}) \cap Y \neq \emptyset$, it follows that $Y \cap \vars(n_N) \neq \emptyset$ as well. Thus $n_N \in \mathcal{I}_Y$. By Definition \ref{def:graded}, this means that for all descendants $o$ of $n_N$, $\pi(o) \cap X = \emptyset$. It follows that $\vars(n_N)$ must still contain all variables in $N$ from $X$; that is, $\vars(N) \cap X \subseteq \vars(n_N)$.

Construct $\T'$ from $\T$ by, for each $N \in \func{GroupBy}(\phi, Y)$, attaching a new leaf labeled by $\func{virtual}(\vars(N) \cap X)$ as a child of $n_N$. 
Since $N \cap X \subseteq \vars(n_N)$ in the initial tree, the width of $\T'$ is equal to the width of $\T$. Moreover, $\T'$ is now a project-join tree for $\psi$.
\end{proof}
% \begin{proof}[Proof Idea]
% In the ``if'' direction, let $\T$ be a project-join tree for $\phi \cup \{C_N : N \in \func{GroupBy}(\phi, Y)\}$. For each $N \in \func{GroupBy}(\phi, Y)$ let $\T_N$ be the subtree of $\T$ containing only the leaves for $N \cup \{C_N\}$, call it $\T_N$. Apply Theorem \ref{thm:free_reduction} to $\T_N$ to get a $(\vars(N) \cap X)$-free project-join tree for $N$, call it $\T_N'$. Finally, let $\T'$ be the subtree of $\T$ containing only the virtual clauses as leaves. Replace the leaf for each virtual clause $C_N$ with $\T_N'$.

% In the ``only if'' direction, one can prove for each $N \in \func{GroupBy}(\phi, Y)$ that there must be some node $n_N$ in the $(X,Y)$-graded tree with $\vars(N) \cap X \subseteq \vars(n_N)$. Add each $C_N$ as a child of $n_N$. 
% \end{proof}