






\section{Preliminaries}

% \paragraph{\textbf{Pseudo-Boolean Functions and Projections.}}
\subsection{Pseudo-Boolean Functions and Projections}

A \emph{pseudo-Boolean function} over a set $X$ of variables is a function $f: 2^X \to \R$. A Boolean formula $\phi$ over variables $X$ can be represented by a pseudo-Boolean function over $X$, denoted $[\phi]: 2^X \rightarrow \R$,
where for all $\tau \in 2^X$, if $\tau$ satisfies $\phi$ then $[\phi](\tau) \equiv 1$ else $[\phi](\tau) \equiv 0$.

Operations on pseudo-Boolean functions include \emph{product} and \emph{projection}.
We define product as follows.
\begin{definition}
\label{def_mult_pro}
    Let $X$ and $Y$ be sets of Boolean variables.
    The \emph{product} of functions $f: 2^X \to \R$ and $g: 2^Y \to \R$ is the function $f \mult g: 2^{X \cup Y} \to \R$ defined for all $\tau \in 2^{X \cup Y}$ by
    $(f \mult g)(\tau) \equiv f(\tau \cap X) \mult g(\tau \cap Y).$
\end{definition}

Product generalizes conjunction of Boolean formulas: if $\alpha$ and $\beta$ are Boolean formulas, then $[\alpha] \mult [\beta] = [\alpha \land \beta]$.

We need two types of projections on pseudo-Boolean functions: $\Sigma$-projection and $\exists$-projection; each eliminates a single variable. 
We first define $\Sigma$-projection.
\begin{definition}
\label{def_sum}
    Let $X$ be a set of Boolean variables, and let $x \in X$.
    The \emph{$\Sigma$-projection} of a function $f: 2^X \to \R$ \wrt{} $x$ is the function $\Sigma_x f: 2^{X \setminus \set{x}} \to \R$ defined for all $\tau \in 2^{X \setminus \set{x}}$ by
    $\pars{\Sigma_x f}(\tau) \equiv f(\tau) + f(\tau \cup \set{x}).$
\end{definition}

$\Sigma$-projection is also known as \emph{additive projection} or 
\emph{marginalization}.
We next define $\exists$-projection.
\begin{definition}
\label{def_exist}
    Let $X$ be a set of Boolean variables, and let $x \in X$.
    The \emph{$\exists$-projection} of a function $f: 2^X \to \R$ \wrt{} $x$ is the function $\exists_x f: 2^{X \setminus \set{x}} \to \R$ defined for all $\tau \in 2^{X \setminus \set{x}}$ by $\pars{\exists_x f}(\tau) \equiv \max(f(\tau), f(\tau \cup \set{x}))$.
\end{definition}

$\exists$-projection is also called \emph{disjunctive projection} and generalizes existential quantification: if $\alpha$ is a Boolean formula and $x \in \vars(\alpha)$, then $\exists_x [\alpha] = [\exists x ~ \alpha]$.

% If $f: 2^X \to \B$ represents a Boolean formula, then $\exists_x f \equiv f[x \mapsto 0] \lor f[x \mapsto 1]$.

$\Sigma$-projection and $\exists$-projection are each independently commutative. 
That is, for all $x, y \in X$ and $f: 2^X \to \R$, we have that $\Sigma_x \Sigma_y f = \Sigma_y \Sigma_x f$ and $\exists_x \exists_y f = \exists_y \exists_x f$. 
Thus, for all $X = \{x_1, \ldots, x_n\}$, define $\Sigma_X f \equiv \Sigma_{x_1} \ldots \Sigma_{x_n} f$ and $\exists_X f \equiv \exists_{x_1} \ldots \exists_{x_n} f$. 
We also take the convention that $\Sigma_\varnothing f \equiv \exists_\varnothing f \equiv f$.

In general, $\Sigma$-projection does not commute with $\exists$-projection. For example, if $f(x, y) = x \oplus y$ (XOR), then $\Sigma_x \exists_y f \neq \exists_y \Sigma_x f$.

% When performing a product followed by a projection, it is often possible to perform the projection first.
% This is known as \emph{early projection} \cite{mcmahan2004projection}.
% \begin{theorem}[Early Projection]
% \label{thm_early_proj}
%     Let $X$ and $Y$ be sets of variables.
%     For all functions $f: 2^X \to \R$ and $g: 2^Y \to \R$, if $x \in X \setminus Y$, then $\Sigma_x (f \mult g) = \pars{\Sigma_x f} \mult g$ and $\exists_x (f \mult g) = \pars{\exists_x f} \mult g.$
%     % As a corollary, for all $X' \subseteq X \setminus Y$,
%     % $$\exists_{X'} (A \mult B) = \pars{\exists_{X'} A} \mult B.$$
% \end{theorem}
% Early projection is a key technique in symbolic computation in many settings, e.g. database-query optimization \cite{kolaitis2000conjunctive}, symbolic model checking \cite{burch1991symbolic}, satisfiability solving \cite{pan2005symbolic}, and model counting \cite{dudek2020addmc}.



% \paragraph{\textbf{Weighted Projected Model Counting.}}
\subsection{Weighted Projected Model Counting}

We compute the total weight, subject to a given weight function and a set of irrelevant variables, of all models of an input propositional formula.
Formally:
\begin{definition}
     Let $\phi$ be a Boolean formula, $\{X, Y\}$ be a partition of $\vars(\phi)$, and $W: 2^X \to \R$ be a pseudo-Boolean function. We say that $(X, Y, \phi, W)$ is an instance of \emph{weighted projected model counting}.
    The \emph{$W$-weighted $Y$-projected model count} of $\phi$ is
    $\func{WPMC}(\phi, W, Y) \equiv \sum_{\tau \in 2^X} \pars{ W(\tau) \mult \max_{\sigma \in 2^Y} [\phi](\tau \cup \sigma) }$.
\end{definition}

Variables in $X$ are called \emph{relevant} or \emph{additive}, and variables in $Y$ are called \emph{irrelevant} or \emph{disjunctive}. 
For the special case of \emph{unprojected model counting}, all variables are relevant, and the \emph{$W$-weighted model count} is $\func{WPMC}(\phi, W, \emptyset)$.

Weights are usually given by a \emph{literal-weight function} $W = \prod_{x \in X} W_x$, where the factors are functions $W_x : 2^{\set{x}} \to \R$.
In detail, a positive literal $x$ has weight $W_x(\set{x})$, and a negative literal $\neg x$ has weight $W_x(\emptyset)$.

% \paragraph{\textbf{Graphs.}}
\subsection{Graphs}

A \emph{graph} $G$ has a set $\V{G}$ of vertices, a set $\E{G}$ of undirected edges, a function $\delta_G: \V{G} \to 2^{\E{G}}$ that gives the set of edges incident to each vertex, and a function $\epsilon_G: \E{G} \to 2^{\V{G}}$ that gives the set of vertices incident to each edge.
Each edge must be incident to exactly two vertices, but multiple edges can exist between two vertices.
A \emph{tree} is a simple, connected, and acyclic graph. 
We often refer to a vertex of a tree as a \emph{node} to avoid confusion with other graphs. % and an edge as an \emph{arc}

A \emph{rooted tree} is a tree $T$ together with a distinguished node $r \in \V{T}$ called the \emph{root}.
In a rooted tree $(T, r)$, each node $n \in \V{T}$ has a (possibly empty) set of \emph{children}, denoted $\C T r n$, which contains all nodes $n'$ adjacent to $n$ such that all paths from $n'$ to $r$ contain $n$.
A \emph{leaf} of a (rooted) tree $T$ is a vertex of degree one (that is not the root), and we use $\Lv{T}$ to denote the set of leaves of $T$.