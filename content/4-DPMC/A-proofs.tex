\section{Proofs}
\label{sec_proofs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Proof of Theorem \ref{thm_valuation_wmc}}

In this section, for pseudo-Boolean functions $f : 2^X \to \R$, we define $\vars(f) \equiv X$.
Notice that a clause $c$ in a CNF formula can be interpreted as a Boolean function $c : 2^{\vars(c)} \to \B$.
Similarly, a set $\phi$ of clauses can be interpreted as the Boolean function $\phi = \prod_{c \in \phi} c$.

Let $X$ be a set of variables and $W = \prod_{x \in X} W_x$ be a literal-weight function.
Given a set $Y \subseteq X$, we define $W_{Y} \equiv \prod_{x \in Y} W_x$.
Notice $W_Y \mult W_Z = W_{Y \cup Z}$ for all sets $Y, Z \subseteq X$.

Let $\phi$ be a CNF formula over a set $X$ of variables, $(T, r, \gamma, \sigma)$ be a project-join tree of $\phi$, and $n \in \V T$.
Denote by $S(n)$ the subtree rooted at $n$.
We define the set $\Phi(n)$ of clauses that correspond to the leaves of $S(n)$:
\begin{align*}
    \Phi(n) \equiv
    \begin{cases}
        \set{\gamma(n)} & \text{if } n \in \Lv T \\
        \bigcup_{o \in \C{T}{r}{n}} \Phi(o) & \text{otherwise}
    \end{cases}
\end{align*}
We also define the set $P(n)$ of all variables to project in the subtree $S(n)$:
\begin{align*}
    P(n) \equiv
    \begin{cases}
       \emptyset & \text{if } n \in \Lv{T} \\
        \pi(n) \cup \bigcup_{o \in \C{T}{r}{n}} P(o) & \text{otherwise}
    \end{cases}
\end{align*}

\begin{lemma}
\label{lemma_disjoint_P}
    In a project-join tree $(T, r, \gamma, \pi)$, let $n$ be an internal node with children $o \ne q$.
    Then $P(o) \cap \vars \pars{\Phi(q) \mult W_{P(q)}} = \emptyset$.
\end{lemma}
\begin{proof}
    Let variable $x \in P(o)$.
    Notice that $x \in \pi(s)$ for some internal node $s$ that is a descendant of $o$.
    Assume there is an arbitrary clause $c \in \phi$ \st{} $x$ appears in $c$.
    By the last property in Definition \ref{def_jointree}, the corresponding leaf $\gamma^{-1}(c)$ is a descendant of $s$ and thus a descendant of $o$.
    So $x$ appears in no descendant leaf of $q$ (as $q$ is a sibling of $o$ in the tree $T$).
    Thus $x \notin \vars(\Phi(q))$.

    Now, note that $P(q) \subseteq \vars(\Phi(q))$, again by Definition \ref{def_jointree}.
    So $x \notin P(q)$.
    Therefore $x \notin \vars(\Phi(q) \mult W_{P(q)}) = \vars(\Phi(q)) \cup \vars(W_{P(q)}) = \vars(\Phi(q)) \cup P(q)$.
    Since $x \in P(o)$ is arbitrary, we have $P(o) \cap \vars \pars{\Phi(q) \mult W_{P(q)}} = \emptyset$.
\qed
\end{proof}

\begin{lemma}
\label{lemma_late_proj}
    In a project-join tree $(T, r, \gamma, \pi)$, let $n$ be an internal node with children $o \ne q$.
    Then:
    $$\proj_{P(o)} \pars{ \Phi(o) \mult W_{P(o)} } \mult \proj_{P(q)} \pars{ \Phi(q) \mult W_{P(q)} } = \proj_{P(o) \cup P(q)} \pars{ \Phi(o) \Phi(q) \mult W_{P(o) \cup P(q)} }$$
\end{lemma}
\begin{proof}
    We have:
    \begin{align*}
        \proj_{P(o)} \pars{ \Phi(o) \mult W_{P(o)} } \mult \proj_{P(q)} \pars{ \Phi(q) \mult W_{P(q)} }
        & = \proj_{P(o)} \pars{ \Phi(o) \mult W_{P(o)} \mult \proj_{P(q)} \pars{ \Phi(q) \mult W_{P(q)} } } \tag{undoing early projection of $P(o)$, observing Lemma \ref{lemma_disjoint_P}} \\
        & = \proj_{P(q)} \proj_{P(o)} \pars{ \Phi(o) \mult W_{P(o)} \mult \Phi(q) \mult W_{P(q)} } \tag{undoing early projection of $P(q)$, observing Lemma \ref{lemma_disjoint_P}} \\
        & = \proj_{P(o)} \proj_{P(q)} \pars{ \Phi(o) \Phi(q) \mult W_{P(o)} W_{P(q)} }
        % \tag{both projection and multiplication are commutative}
        \\
        & = \proj_{P(o) \cup P(q)} \pars{ \Phi(o) \Phi(q) \mult W_{P(o) \cup P(q)} }
    \end{align*}
\qed
\end{proof}

\pagebreak
% \clearpage

\begin{lemma}
\label{lemma_valuation}
    Let $\phi$ be a CNF formula over a set $X$ of variables, $W$ be a literal-weight function over $X$, and $(T, r, \gamma, \pi)$ be a project-join tree of $\phi$.
    Then for every node $n$ in $T$:
    $$f^W_n = \proj_{P(n)} \pars{ \Phi(n) \mult W_{P(n)} }$$
    % Regarding the projection operator $\proj$, we use the convention that $\sum_\emptyset g = g$ for pseudo-Boolean functions g.
\end{lemma}
\begin{proof}
    Notice that both pseudo-Boolean functions have the same variables in their domains:
    \begin{align*}
        \vars \pars{f^W_n}
        & = \vars(n) \\
        & = \vars(\Phi(n)) \setminus P(n) \\
        & = \vars \pars{ \proj_{P(n)} \pars{ \Phi(n) \mult W_{P(n)} } }
    \end{align*}

    We employ structural induction on $n \in \V T$.
    In the base case, $n$ is a leaf.
    So $P(n) = \emptyset$ and $\Phi(n) = \set{\gamma(n)}$.
    We have:
    \begin{align*}
        f^W_n
        & = \gamma(n) \tag{Equation \eqref{eq_valuation}} \\
        & = \prod_{c \in \Phi(n)} c \tag{singleton set} \\
        & = \Phi(n)
        % \tag{clause conjunction corresponds to function multiplication}
        \\
        & = \Phi(n) \mult \prod_{x \in \emptyset} W_x \tag{an empty product is equal to the number $1$} \\
        & = \Phi(n) \mult W_\emptyset \\
        & = \Phi(n) \mult W_{P(n)} \\
        & = \proj_{\emptyset} \pars{ \Phi(n) \mult W_{P(n)} } \tag{convention on projection} \\
        & = \proj_{P(n)} \pars{ \Phi(n) \mult W_{P(n)} }
    \end{align*}

    In the inductive case, $n$ is an internal node of $T$.
    Our induction hypothesis is that
    $$f^W_o = \proj_{P(o)} \pars{ \Phi(o) \mult W_{P(o)} }$$
    for every child node $o$ of $n$.
    Then we have:
    \begin{align*}
        f^W_n
        & = \proj_{\pi(n)} \pars{\prod_{o \in \C{T}{r}{n}} f^W_o \mult \prod_{x \in \pi(n)} W_x} \tag{Equation \eqref{eq_valuation}} \\
        & = \proj_{\pi(n)} \pars{\prod_{o \in \C{T}{r}{n}} f^W_o \mult W_{\pi(n)}} \\
        & = \proj_{\pi(n)} \pars{\prod_{o \in \C{T}{r}{n}} \pars{\proj_{P(o)} \pars{ \Phi(o) \mult W_{P(o)} } } \mult W_{\pi(n)}} \tag{induction hypothesis} \\
        & = \proj_{\pi(n)} \pars{ \proj_{\bigcup_{s \in \C{T}{r}{n}} P(s)} \pars{ \prod_{o \in \C{T}{r}{n}} \Phi(o) \mult W_{\bigcup_{t \in \C{T}{r}{n}} P(t)} } \mult W_{\pi(n)} } \tag{applying Lemma \ref{lemma_late_proj} multiple times} \\
        & = \proj_{\pi(n)} \pars{ \proj_{\bigcup_{s \in \C{T}{r}{n}} P(s)} \pars{ \prod_{o \in \C{T}{r}{n}} \Phi(o) \mult W_{\bigcup_{t \in \C{T}{r}{n}} P(t)} \mult W_{\pi(n)}} } \tag{undoing early projection, observing $\pi(n) \cap \bigcup_{s \in \C{T}{r}{n}} P(s) = \emptyset$} \\
        & = \proj_{\pi(n) \cup \bigcup_{s \in \C{T}{r}{n}} P(s)} \pars{ \prod_{o \in \C{T}{r}{n}} \Phi(o) \mult W_{\bigcup_{t \in \C{T}{r}{n}} P(t) \cup \pi(n)} } \\
        & = \proj_{P(n)} \pars{ \prod_{o \in \C{T}{r}{n}} \Phi(o) \mult W_{P(n)} } \tag{definition of $P(n)$} \\
        & = \proj_{P(n)} \pars{ \Phi(n) \mult W_{P(n)} } \tag{as $\Phi(n) = \bigcup_{o \in \C{T}{r}{n}} \Phi(o)$ is a set of clauses}
    \end{align*}
\qed
\end{proof}

Now, we can prove Theorem \ref{thm_valuation_wmc}.
\begin{proof}
    As $r$ is the root of the project-join tree, $P(r) = X$ and $\Phi(r) = \phi$.
    Then:
    \begin{align*}
        f^W_r(\emptyset)
        & = \pars{ \proj_{P(r)} \pars{ \Phi(r) \mult W_{P(r)} } } (\emptyset) \tag{Lemma \ref{lemma_valuation}} \\
        & = \pars{ \proj_{X} \pars{ \phi \mult W_{X} } } (\emptyset) \\
        & = \pars{ \proj_{X} \pars{ \phi \mult W } } (\emptyset) \\
        & = W(\phi)
    \end{align*}
\qed
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Proof of Theorem \ref{thm_csp_jt}}

In this section, we assume the antecedents of Theorem \ref{thm_csp_jt} regarding the functions $\clusterVarOrder$, $\clauseRank$, and $\chosenCluster$.
Notice that for each $i = 1, 2, \ldots, m$ in Algorithm \ref{alg_csp_jt}, we have the following:
\begin{itemize}
    \item $\Gamma_i$ is a set of clauses
    \item $\kappa_i$ is a set of nodes that includes leaves $l$ \st{} $\gamma(l) \in \Gamma_i$
    \item $n_i$ is an internal node
    \item $n_i$'s children include the leaves in $\kappa_i$
    \item $\pi(n_i) = X_i$
\end{itemize}

We show that the first property in Definition \ref{def_jointree} holds:
\begin{lemma}[Property \ref{prop1}]
\label{lemma_prop1}
    The set $\set{\pi(n) : n \in \V T \setminus \Lv T}$ is a partition of $X$.
\end{lemma}
\begin{proof}
    For each $i = 1, 2, \ldots, m$, Algorithm \ref{alg_csp_jt} constructs an internal nodes $n_i$ with $\pi(n_i) = X_i$.
    Recall that $\set{X_i}_{i = 1}^m$ is a partition of $X$.
    Then $\set{\pi(n_i)}_{i = 1}^m$ is the same partition of $X$.
\qed
\end{proof}

We show that the second property in Definition \ref{def_jointree} holds through the following lemmas.

\begin{lemma}
\label{lemma_unprojected}
    Let $1 \le p < q \le m$.
    Assume some $x \in \vars(\Gamma_p) \cap X_q$.
    Then $x \in \vars(n_p)$.
\end{lemma}
\begin{proof}
    Notice $x \in X_q = \pi(n_q)$.
    Then $x$ is projected in $n_q$.
    Since $p < q$, we know $x$ is projected in neither $n_p$ nor a descendants of $n_p$.
    Since $x \in \vars(\Gamma_p)$, we know $x$ remains in $n_p$.
\qed
\end{proof}

\begin{lemma}
\label{lemma_internal_descedant}
    Let $1 \le p_0 < q \le m$.
    Assume $\vars(\Gamma_{p_0}) \cap X_q \ne \emptyset$.
    Then the internal node $n_{p_0}$ is a descendant of the node $n_q$.
\end{lemma}
\begin{proof}
    Let $n_{p_1}, n_{p_2}, \ldots$ be the parent, grandparent,\ldots{} of $n_{p_0}$.
    By way of contradiction, assume every $p_i \ne q$.
    Let $x$ be a variable in $\vars(\Gamma_{p_0}) \cap X_q \ne \emptyset$.
    By Lemma \ref{lemma_unprojected}, we know $x \in \vars(n_{p_0})$.
    Notice that for all $i = 0, 1, 2, \ldots$, we have:
    \begin{itemize}
        \item $x \notin X_{p_i}$, as $x \in X_q$ already
        \item $x \in \vars(n_{p_i})$, as $x$ remains from $n_{p_0}$ without being projected according to $\pi(n_{p_i}) = X_{p_i}$
        \item $p_i < p_{i + 1} = \chosenCluster(n_{p_i}) \le q$ by Condition \ref{cond3} of Theorem \ref{thm_csp_jt}, as $x \in \pi(n_q) \cap \vars(n_{p_{i+1}}) = X_q \cap \vars(n_{p_{i+1}}) \ne \emptyset$
    \end{itemize}
    So the strictly increasing sequence $\seq{p_i}_i$ must contain $q$, contradiction.
\qed
\end{proof}

\begin{lemma}
\label{lemma_earlier_cluster}
    Let $1 \le p, q \le m$.
    Assume $\vars(\Gamma_p) \cap X_q \ne \emptyset$.
    Then $p \le q$.
\end{lemma}
\begin{proof}
    To the contrary, assume $p > q$.
    Then by construction, $X_q \cap \vars(\Gamma_p) = \emptyset$, contradiction.
\qed
\end{proof}

\begin{lemma}[Property \ref{prop2}]
\label{lemma_prop2}
    Let $1 \le q \le m$ and variable $x \in \pi(n_q)$.
    Take an arbitrary clause $c \in \phi$ \st{} $x \in \vars(c)$.
    Then the leaf $\gamma^{-1}(c)$ is a descendant of $n_q$.
\end{lemma}
\begin{proof}
    Notice that $c \in \Gamma_p$ for some $1 \le p \le m$.
    Then $x \in \vars(c) \subseteq \vars(\Gamma_p)$.
    Note that $x \in \pi(n_q) = X_q$.
    Thus $p \le q$ by Lemma \ref{lemma_earlier_cluster}.

    Let $l = \gamma^{-1}(c)$.
    Notice that $l \in \kappa_p$ (as $c \in \Gamma_p$).
    So $l$ is a child of the node $n_p$.
    \begin{itemize}
        \item If $p = q$, then $l$ is a child of $n_q$, and we are done.
        \item If $p < q$, by Lemma \ref{lemma_internal_descedant}, we know $n_p$ is a descendant of $n_q$, as $x \in \vars(\Gamma_p) \cap \pi(n_q) = \vars(\Gamma_p) \cap X_q \ne \emptyset$.
        Then $l$ is a descendant of $n_q$.
    \end{itemize}
\qed
\end{proof}

Now we can prove Theorem \ref{thm_csp_jt}
\begin{proof}
    Algorithm \ref{alg_csp_jt} returns a tree $T$ with root $n_m$, bijection $\gamma : \Lv T \to \phi$, and labeling function $\pi : \V T \setminus \Lv T \to 2^X$.
    The project-join tree properties are satisfied, by Lemma \ref{lemma_prop1} and Lemma \ref{lemma_prop2}
\qed
\end{proof}
