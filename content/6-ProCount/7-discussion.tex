\section{Chapter Summary}
\label{sec_procount_discussion}

We adapted the dynamic-programming framework from Chapter \ref{ch:dpmc} to perform projected model counting by requiring project-join trees to be graded.
This framework decomposes projected model counting into two phases.
First, the planning phase produces a graded project-join tree from a CNF formula.
Second, the execution phase uses the this tree to guide the computation of the projected model count of the formula \wrt{} a literal-weight function. 
We proved that algorithms for building project-join trees can be used in a black-box way to build graded project-join trees.

{ \color{blue}
The primary finding of this chapter is that our dynamic-programming framework of planning and execution is a competitive approach to projected model counting.
We found in the planning phase that planning based on tree-decomposition tools continues to outperform planning based on constraint-satisfaction heuristics, even when considering graded project-join trees.
Although requiring the project-join trees to be graded increased their width, our planning techniques were able to find low-width graded join trees.
Overall, our planning techniques were able to find low-width graded project-join trees for a significant number of benchmarks.
The resulting tool \procount{} was competitive with the exact weighted projected model counters \dfp{} \cite{lagniez2019recursive}, \projmc{} \cite{lagniez2019recursive}, and \ssat{} \cite{lee2017solving}. 
\procount{} considerably improves the virtual best solver and thus is a valuable addition to the portfolio.
}  % diff