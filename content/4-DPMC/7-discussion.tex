\section{Chapter Summary}
\label{sec_discussion}

In this chapter, we introduced the concept of project-join trees for weighted model counting.
These trees are at the center of a dynamic-programming framework that unifies and generalizes several model counting algorithms, including those based on ADDs \cite{DPV20} and database management systems \cite{fichte2020exploiting}.
This framework performs model counting in two phases.
First, the planning phase produces a project-join tree from a CNF formula.
We implemented a planner \Htb{} based on constraint-satisfaction heuristics
\cite{tarjan1984simple,koster2001treewidth,dechter03,dechter99,bouquet1999gestion}
and a planner \Lg{} based on tree-decomposition tools \cite{strasser2017computing,Tamaki17,AMW17}.
Second, the execution phase uses the project-join tree to guide the dynamic-programming computation of the model count of the formula \wrt{} a literal-weight function.
We implemented an executor \Dmc{} based on ADDs \cite{DPV20,somenzi2015cudd} and an executor \Tensor{} based on tensors \cite{numpy}.
We evaluated the resulting tool \Dpmc{} empirically in the context of model counting.

{ \color{blue}
The primary findings of this chapter are the comparisons between the planning and execution approaches enabled by our framework.
We found in the planning phase that tree-decomposition tools tend to produce project-join trees of lower widths in shorter times.
We found in the execution phase that sparse ADDs outperform dense tensors on single CPU cores.
Overall, although no single model counter dominates, \Dpmc{} considerably improves a portfolio of existing state-of-the-art counters (\cachet{} \cite{sang2004combining}, \ctd{} \cite{darwiche2004new}, \df{} \cite{LM17}, and \minictd{} \cite{OD15}) and so is a valuable addition to the portfolio.
} % diff